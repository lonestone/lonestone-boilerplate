// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * CreateCommentSchema
 *
 * Schema for creating a comment
 */
export const zCreateCommentSchema = z.object({
  content: z.string().min(1).max(1000),
  parentId: z.optional(
    z
      .uuid()
      .regex(
        /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      ),
  ),
});

/**
 * TokenUsage
 *
 * Token usage information for an AI generation
 */
export const zTokenUsage = z.object({
  promptTokens: z.number(),
  completionTokens: z.number(),
  totalTokens: z.number(),
});

/**
 * AiCoreMessage
 *
 * A message in the conversation history following Vercel AI SDK patterns
 */
export const zAiCoreMessage = z.object({
  role: z.enum(["user", "assistant", "system", "tool"]),
  content: z.string(),
});

/**
 * ToolCall
 *
 * A tool call made by the AI
 */
export const zToolCall = z.object({
  toolCallId: z.string(),
  toolName: z.string(),
  args: z.record(z.string(), z.unknown()),
});

/**
 * ToolResult
 *
 * The result of a tool call
 */
export const zToolResult = z.object({
  toolCallId: z.string(),
  toolName: z.string(),
  result: z.unknown(),
});

/**
 * ChatResponse
 *
 * Response from AI chat
 */
export const zChatResponse = z.object({
  usage: z.optional(zTokenUsage),
  finishReason: z.optional(z.string()),
  result: z.unknown(),
  messages: z.optional(z.array(zAiCoreMessage)),
  toolCalls: z.optional(z.array(zToolCall)),
  toolResults: z.optional(z.array(zToolResult)),
});

/**
 * CommentSchema
 *
 * Schema for a comment
 */
export const zCommentSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  content: z.string(),
  authorName: z.union([z.string(), z.null()]),
  createdAt: z.string(),
  user: z.union([
    z.object({
      id: z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
      name: z.string(),
    }),
    z.null(),
  ]),
  parentId: z.union([
    z
      .uuid()
      .regex(
        /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      ),
    z.null(),
  ]),
  replyIds: z.optional(
    z.array(
      z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
    ),
  ),
  replyCount: z.optional(z.number()),
});

/**
 * CommentsSchema
 *
 * Schema for a paginated list of comments
 */
export const zCommentsSchema = z.object({
  data: z.array(zCommentSchema),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * PostContentSchema
 *
 * Schema for content items (text, image, video)
 */
export const zPostContentSchema = z.union([
  z.object({
    type: z.literal("text"),
    data: z.string(),
  }),
  z.object({
    type: z.literal("image"),
    data: z.string(),
  }),
  z.object({
    type: z.literal("video"),
    data: z.string(),
  }),
]);

/**
 * CreatePostSchema
 *
 * Schema for creating/updating a post
 */
export const zCreatePostSchema = z.object({
  title: z.string().min(1),
  content: z.array(zPostContentSchema),
});

/**
 * UpdatePostSchema
 *
 * Schema for updating a post
 */
export const zUpdatePostSchema = z.object({
  title: z.optional(z.string().min(1)),
  content: z.optional(z.array(zPostContentSchema)),
});

/**
 * PostVersionSchema
 *
 * Schema for a post version
 */
export const zPostVersionSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  title: z.string(),
  createdAt: z.string(),
});

/**
 * UserPostSchema
 *
 * Schema for a user's post
 */
export const zUserPostSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  slug: z.optional(z.union([z.string(), z.null()])),
  title: z.string(),
  content: z.array(zPostContentSchema),
  versions: z.array(zPostVersionSchema),
  publishedAt: z.optional(z.union([z.string(), z.null()])),
  type: z.enum(["published", "draft"]),
  commentCount: z.optional(z.number()),
});

/**
 * UserPostsSchema
 *
 * Schema for a list of user's posts
 */
export const zUserPostsSchema = z.object({
  data: z.array(
    z.object({
      id: z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
      slug: z.optional(z.union([z.string(), z.null()])),
      title: z.string(),
      versions: z.array(zPostVersionSchema),
      publishedAt: z.optional(z.union([z.string(), z.null()])),
      type: z.enum(["published", "draft"]),
      commentCount: z.optional(z.number()),
      contentPreview: zPostContentSchema,
    }),
  ),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * PublicPostSchema
 *
 * A public post
 */
export const zPublicPostSchema = z.object({
  title: z.string(),
  author: z.object({
    name: z.string(),
  }),
  content: z.array(zPostContentSchema),
  publishedAt: z.string(),
  slug: z.optional(z.string()),
  commentCount: z.optional(z.number()),
});

/**
 * PublicPostsSchema
 *
 * A list of public posts
 */
export const zPublicPostsSchema = z.object({
  data: z.array(
    z.object({
      title: z.string(),
      author: z.object({
        name: z.string(),
      }),
      publishedAt: z.string(),
      slug: z.optional(z.string()),
      commentCount: z.optional(z.number()),
      contentPreview: zPostContentSchema,
    }),
  ),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * AiStreamEvent
 *
 * SSE event for AI text streaming with tool support
 */
export const zAiStreamEvent = z.union([
  z.object({
    type: z.literal("chunk"),
    text: z.string(),
  }),
  z.object({
    type: z.literal("tool-call"),
    toolCallId: z.string(),
    toolName: z.string(),
    args: z.record(z.string(), z.unknown()),
  }),
  z.object({
    type: z.literal("tool-result"),
    toolCallId: z.string(),
    toolName: z.string(),
    result: z.unknown(),
  }),
  z.object({
    type: z.literal("done"),
    fullText: z.string(),
    usage: z.optional(
      z.object({
        promptTokens: z.number(),
        completionTokens: z.number(),
        totalTokens: z.number(),
      }),
    ),
    finishReason: z.optional(z.string()),
  }),
  z.object({
    type: z.literal("error"),
    message: z.string(),
  }),
]);

/**
 * AiGenerateOptions
 *
 * Options for an AI generation
 */
export const zAiGenerateOptions = z.object({
  temperature: z.optional(z.number().gte(0).lte(2)),
  maxTokens: z.optional(z.number().gt(0)),
  topP: z.optional(z.number().gte(0).lte(1)),
  frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
  presencePenalty: z.optional(z.number().gte(-2).lte(2)),
  maxSteps: z.optional(z.number().gt(0)),
  stopWhen: z.optional(z.number().gt(0)),
  telemetry: z.optional(
    z.object({
      langfuseTraceName: z.string(),
      langfuseOriginalPrompt: z.optional(z.string()),
      functionId: z.optional(z.string()),
    }),
  ),
  metadata: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * AiStreamRequest
 *
 * Request for streaming AI text generation. Either prompt (single turn) or messages (conversation history) must be provided.
 */
export const zAiStreamRequest = z.object({
  prompt: z.optional(z.string().min(1)),
  messages: z.optional(z.array(zAiCoreMessage)),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * ChatSchemaType
 *
 * Predefined schema types for testing structured output (only works with single message, not conversation)
 */
export const zChatSchemaType = z.enum([
  "userProfile",
  "task",
  "product",
  "none",
]);

/**
 * ChatRequest
 *
 * Request for AI chat. Either message (single turn) or messages (conversation history) must be provided. Note: schemaType only works with message, not messages.
 */
export const zChatRequest = z.object({
  message: z.optional(z.string().min(1)),
  messages: z.optional(z.array(zAiCoreMessage)),
  conversationId: z.optional(z.string()),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
  schemaType: z.optional(zChatSchemaType),
});

/**
 * PaginationQuerySchema
 *
 * Schema for pagination query
 */
export const zPaginationQuerySchema = z.object({
  offset: z.int().gte(0).lte(9007199254740991).default(0),
  pageSize: z.int().gte(1).lte(100).default(20),
});

/**
 * SortingQueryStringSchema
 *
 * Schema for sorting items
 */
export const zSortingQueryStringSchema = z.string();

/**
 * FilterQueryStringSchema
 *
 * Filtering query string, in the format of "property:rule[:value];property:rule[:value];..."
 * <br> Available rules: eq, neq, gt, gte, lt, lte, like, nlike, in, nin, isnull, isnotnull
 * <br> Available properties: title
 */
export const zFilterQueryStringSchema = z.string();

export const zCommentsControllerPostSlug = z.string();

export const zCommentsControllerGetCommentsFilterItem = z.object({
  property: z.literal("content"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zCommentsControllerGetCommentsFilterArray = z.array(
  zCommentsControllerGetCommentsFilterItem,
);

export const zCommentsControllerGetCommentsSortItem = z.object({
  property: z.union([z.literal("createdAt"), z.literal("authorName")]),
  direction: z.enum(["asc", "desc"]),
});

export const zCommentsControllerGetCommentsSortArray = z.array(
  zCommentsControllerGetCommentsSortItem,
);

export const zCommentsControllerGetCommentRepliesSortItem = z.object({
  property: z.union([z.literal("createdAt"), z.literal("authorName")]),
  direction: z.enum(["asc", "desc"]),
});

export const zCommentsControllerGetCommentRepliesSortArray = z.array(
  zCommentsControllerGetCommentRepliesSortItem,
);

export const zPostControllerGetUserPostsFilterItem = z.object({
  property: z.literal("title"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zPostControllerGetUserPostsFilterArray = z.array(
  zPostControllerGetUserPostsFilterItem,
);

export const zPostControllerGetUserPostsSortItem = z.object({
  property: z.union([z.literal("title"), z.literal("createdAt")]),
  direction: z.enum(["asc", "desc"]),
});

export const zPostControllerGetUserPostsSortArray = z.array(
  zPostControllerGetUserPostsSortItem,
);

export const zPublicPostControllerGetPostsFilterItem = z.object({
  property: z.literal("title"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zPublicPostControllerGetPostsFilterArray = z.array(
  zPublicPostControllerGetPostsFilterItem,
);

export const zPublicPostControllerGetPostsSortItem = z.object({
  property: z.union([z.literal("title"), z.literal("createdAt")]),
  direction: z.enum(["asc", "desc"]),
});

export const zPublicPostControllerGetPostsSortArray = z.array(
  zPublicPostControllerGetPostsSortItem,
);

export const zAppControllerGetHelloData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zCommentsControllerGetCommentsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.object({
    filter: z.optional(zCommentsControllerGetCommentsFilterArray),
    sort: z.optional(zCommentsControllerGetCommentsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a paginated list of comments
 */
export const zCommentsControllerGetCommentsResponse = zCommentsSchema;

export const zCommentsControllerCreateCommentData = z.object({
  body: z.object({
    content: z.string().min(1).max(1000),
    parentId: z.optional(
      z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
    ),
  }),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a comment
 */
export const zCommentsControllerCreateCommentResponse = zCommentSchema;

export const zCommentsControllerGetCommentCountData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zCommentsControllerGetCommentRepliesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    commentId: z.string(),
    postSlug: z.string(),
  }),
  query: z.object({
    sort: z.optional(zCommentsControllerGetCommentRepliesSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a paginated list of comments
 */
export const zCommentsControllerGetCommentRepliesResponse = zCommentsSchema;

export const zCommentsControllerDeleteCommentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    commentId: z.string(),
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPostControllerGetUserPostsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    filter: z.optional(zPostControllerGetUserPostsFilterArray),
    sort: z.optional(zPostControllerGetUserPostsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a list of user's posts
 */
export const zPostControllerGetUserPostsResponse = zUserPostsSchema;

export const zPostControllerCreatePostData = z.object({
  body: z.object({
    title: z.string().min(1),
    content: z.array(
      z.union([
        z.object({
          type: z.literal("text"),
          data: z.string(),
        }),
        z.object({
          type: z.literal("image"),
          data: z.string(),
        }),
        z.object({
          type: z.literal("video"),
          data: z.string(),
        }),
      ]),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerCreatePostResponse = zUserPostSchema;

export const zPostControllerGetUserPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerGetUserPostResponse = zUserPostSchema;

export const zPostControllerUpdatePostData = z.object({
  body: z.object({
    title: z.optional(z.string().min(1)),
    content: z.optional(
      z.array(
        z.union([
          z.object({
            type: z.literal("text"),
            data: z.string(),
          }),
          z.object({
            type: z.literal("image"),
            data: z.string(),
          }),
          z.object({
            type: z.literal("video"),
            data: z.string(),
          }),
        ]),
      ),
    ),
  }),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerUpdatePostResponse = zUserPostSchema;

export const zPostControllerPublishPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPostControllerUnpublishPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPublicPostControllerGetRandomPostData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A public post
 */
export const zPublicPostControllerGetRandomPostResponse = zPublicPostSchema;

export const zPublicPostControllerGetPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slug: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * A public post
 */
export const zPublicPostControllerGetPostResponse = zPublicPostSchema;

export const zPublicPostControllerGetPostsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    filter: z.optional(zPublicPostControllerGetPostsFilterArray),
    sort: z.optional(zPublicPostControllerGetPostsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * A list of public posts
 */
export const zPublicPostControllerGetPostsResponse = zPublicPostsSchema;

export const zAiExampleControllerChatData = z.object({
  body: z.object({
    message: z.optional(z.string().min(1)),
    messages: z.optional(
      z.array(
        z.object({
          role: z.enum(["user", "assistant", "system", "tool"]),
          content: z.string(),
        }),
      ),
    ),
    conversationId: z.optional(z.string()),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
    schemaType: z.optional(z.enum(["userProfile", "task", "product", "none"])),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Response from AI chat
 */
export const zAiExampleControllerChatResponse = zChatResponse;

export const zAiExampleControllerStreamData = z.object({
  body: z.object({
    prompt: z.optional(z.string().min(1)),
    messages: z.optional(
      z.array(
        z.object({
          role: z.enum(["user", "assistant", "system", "tool"]),
          content: z.string(),
        }),
      ),
    ),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});
