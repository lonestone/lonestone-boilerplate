// This file is auto-generated by @hey-api/openapi-ts

import { z } from "zod";

/**
 * CreateCommentSchema
 *
 * Schema for creating a comment
 */
export const zCreateCommentSchema = z.object({
  content: z.string().min(1).max(1000),
  parentId: z.optional(
    z
      .uuid()
      .regex(
        /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      ),
  ),
});

/**
 * TokenUsage
 *
 * Token usage information for an AI generation
 */
export const zTokenUsage = z.object({
  promptTokens: z.number(),
  completionTokens: z.number(),
  totalTokens: z.number(),
});

/**
 * GenerateTextResponse
 *
 * Response from text generation
 */
export const zGenerateTextResponse = z.object({
  usage: z.optional(zTokenUsage),
  finishReason: z.optional(z.string()),
  result: z.string(),
});

/**
 * GenerateObjectResponse
 *
 * Response from structured object generation
 */
export const zGenerateObjectResponse = z.object({
  usage: z.optional(zTokenUsage),
  finishReason: z.optional(z.string()),
  result: z.unknown(),
});

/**
 * ChatMessageWithSchemaType
 *
 * A message with optional schemaType metadata for identifying structured output
 */
export const zChatMessageWithSchemaType = z.object({
  role: z.enum(["user", "assistant", "system", "tool"]),
  content: z.string(),
  metadata: z.optional(
    z.object({
      isConsideredSystemMessage: z.optional(z.boolean()),
      usage: z.optional(
        z.object({
          promptTokens: z.number(),
          completionTokens: z.number(),
          totalTokens: z.number(),
        }),
      ),
      finishReason: z.optional(z.string()),
      timestamp: z.optional(
        z.iso
          .datetime()
          .regex(
            /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/,
          ),
      ),
      schemaType: z.optional(
        z.enum(["userProfile", "task", "product", "recipe", "none"]),
      ),
    }),
  ),
});

/**
 * ChatSchemaType
 *
 * Predefined schema types for testing structured output
 */
export const zChatSchemaType = z.enum([
  "userProfile",
  "task",
  "product",
  "recipe",
  "none",
]);

/**
 * ToolCall
 *
 * A tool call made by the AI
 */
export const zToolCall = z.object({
  toolCallId: z.string(),
  toolName: z.string(),
  args: z.record(z.string(), z.unknown()),
});

/**
 * ToolResult
 *
 * The result of a tool call
 */
export const zToolResult = z.object({
  toolCallId: z.string(),
  toolName: z.string(),
  result: z.unknown(),
});

/**
 * ChatResponse
 *
 * Response from AI chat conversation
 */
export const zChatResponse = z.object({
  usage: z.optional(zTokenUsage),
  finishReason: z.optional(z.string()),
  result: z.string(),
  messages: z.array(zChatMessageWithSchemaType),
  toolCalls: z.optional(z.array(zToolCall)),
  toolResults: z.optional(z.array(zToolResult)),
});

/**
 * CommentSchema
 *
 * Schema for a comment
 */
export const zCommentSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  content: z.string(),
  authorName: z.union([z.string(), z.null()]),
  createdAt: z.string(),
  user: z.union([
    z.object({
      id: z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
      name: z.string(),
    }),
    z.null(),
  ]),
  parentId: z.union([
    z
      .uuid()
      .regex(
        /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
      ),
    z.null(),
  ]),
  replyIds: z.optional(
    z.array(
      z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
    ),
  ),
  replyCount: z.optional(z.number()),
});

/**
 * CommentsSchema
 *
 * Schema for a paginated list of comments
 */
export const zCommentsSchema = z.object({
  data: z.array(zCommentSchema),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * PostContentSchema
 *
 * Schema for content items (text, image, video)
 */
export const zPostContentSchema = z.union([
  z.object({
    type: z.literal("text"),
    data: z.string(),
  }),
  z.object({
    type: z.literal("image"),
    data: z.string(),
  }),
  z.object({
    type: z.literal("video"),
    data: z.string(),
  }),
]);

/**
 * CreatePostSchema
 *
 * Schema for creating/updating a post
 */
export const zCreatePostSchema = z.object({
  title: z.string().min(1),
  content: z.array(zPostContentSchema),
});

/**
 * UpdatePostSchema
 *
 * Schema for updating a post
 */
export const zUpdatePostSchema = z.object({
  title: z.optional(z.string().min(1)),
  content: z.optional(z.array(zPostContentSchema)),
});

/**
 * PostVersionSchema
 *
 * Schema for a post version
 */
export const zPostVersionSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  title: z.string(),
  createdAt: z.string(),
});

/**
 * UserPostSchema
 *
 * Schema for a user's post
 */
export const zUserPostSchema = z.object({
  id: z
    .uuid()
    .regex(
      /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
    ),
  slug: z.optional(z.union([z.string(), z.null()])),
  title: z.string(),
  content: z.array(zPostContentSchema),
  versions: z.array(zPostVersionSchema),
  publishedAt: z.optional(z.union([z.string(), z.null()])),
  type: z.enum(["published", "draft"]),
  commentCount: z.optional(z.number()),
});

/**
 * UserPostsSchema
 *
 * Schema for a list of user's posts
 */
export const zUserPostsSchema = z.object({
  data: z.array(
    z.object({
      id: z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
      slug: z.optional(z.union([z.string(), z.null()])),
      title: z.string(),
      versions: z.array(zPostVersionSchema),
      publishedAt: z.optional(z.union([z.string(), z.null()])),
      type: z.enum(["published", "draft"]),
      commentCount: z.optional(z.number()),
      contentPreview: zPostContentSchema,
    }),
  ),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * PublicPostSchema
 *
 * A public post
 */
export const zPublicPostSchema = z.object({
  title: z.string(),
  author: z.object({
    name: z.string(),
  }),
  content: z.array(zPostContentSchema),
  publishedAt: z.string(),
  slug: z.optional(z.string()),
  commentCount: z.optional(z.number()),
});

/**
 * PublicPostsSchema
 *
 * A list of public posts
 */
export const zPublicPostsSchema = z.object({
  data: z.array(
    z.object({
      title: z.string(),
      author: z.object({
        name: z.string(),
      }),
      publishedAt: z.string(),
      slug: z.optional(z.string()),
      commentCount: z.optional(z.number()),
      contentPreview: zPostContentSchema,
    }),
  ),
  meta: z.object({
    offset: z.number(),
    pageSize: z.number(),
    itemCount: z.number(),
    hasMore: z.boolean(),
  }),
});

/**
 * AiCoreMessage
 *
 * A message in the conversation history following Vercel AI SDK patterns
 */
export const zAiCoreMessage = z.object({
  role: z.enum(["user", "assistant", "system", "tool"]),
  content: z.string(),
  metadata: z.optional(
    z.object({
      isConsideredSystemMessage: z.optional(z.boolean()),
      usage: z.optional(zTokenUsage),
      finishReason: z.optional(z.string()),
      timestamp: z.optional(
        z.iso
          .datetime()
          .regex(
            /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/,
          ),
      ),
    }),
  ),
});

/**
 * AiStreamEvent
 *
 * SSE event for AI text streaming with tool support
 */
export const zAiStreamEvent = z.union([
  z.object({
    type: z.literal("chunk"),
    text: z.string(),
  }),
  z.object({
    type: z.literal("tool-call"),
    toolCallId: z.string(),
    toolName: z.string(),
    args: z.record(z.string(), z.unknown()),
  }),
  z.object({
    type: z.literal("tool-result"),
    toolCallId: z.string(),
    toolName: z.string(),
    result: z.unknown(),
  }),
  z.object({
    type: z.literal("done"),
    fullText: z.string(),
    usage: z.optional(
      z.object({
        promptTokens: z.number(),
        completionTokens: z.number(),
        totalTokens: z.number(),
      }),
    ),
    finishReason: z.optional(z.string()),
  }),
  z.object({
    type: z.literal("error"),
    message: z.string(),
  }),
]);

/**
 * Task
 *
 * A task
 */
export const zTask = z.object({
  title: z.string(),
  description: z.string(),
  priority: z.enum(["low", "medium", "high"]),
  dueDate: z.optional(z.string()),
  tags: z.optional(z.array(z.string())),
});

/**
 * Product
 *
 * A product
 */
export const zProduct = z.object({
  name: z.string(),
  price: z.number(),
  description: z.string(),
  category: z.string(),
  inStock: z.boolean(),
  features: z.optional(z.array(z.string())),
});

/**
 * Recipe
 *
 * A recipe
 */
export const zRecipe = z.object({
  name: z.string(),
  description: z.string(),
  prepTime: z.string(),
  cookTime: z.string(),
  servings: z.number(),
  difficulty: z.enum(["easy", "medium", "hard"]),
  ingredients: z.array(
    z.object({
      name: z.string(),
      quantity: z.string(),
    }),
  ),
  instructions: z.array(z.string()),
  tips: z.optional(z.array(z.string())),
});

/**
 * UserProfile
 *
 * A user profile
 */
export const zUserProfile = z.object({
  name: z.string(),
  age: z.number(),
  email: z
    .email()
    .regex(
      /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/,
    ),
  bio: z.optional(z.string()),
  skills: z.optional(z.array(z.string())),
});

/**
 * AiGenerateOptions
 *
 * Options for an AI generation
 */
export const zAiGenerateOptions = z.object({
  temperature: z.optional(z.number().gte(0).lte(2)),
  maxTokens: z.optional(z.number().gt(0)),
  topP: z.optional(z.number().gte(0).lte(1)),
  frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
  presencePenalty: z.optional(z.number().gte(-2).lte(2)),
  maxSteps: z.optional(z.number().gt(0)),
  stopWhen: z.optional(z.number().gt(0)),
  telemetry: z.optional(
    z.object({
      langfuseTraceName: z.string(),
      langfuseOriginalPrompt: z.optional(z.string()),
      functionId: z.optional(z.string()),
    }),
  ),
  metadata: z.optional(z.record(z.string(), z.unknown())),
});

/**
 * GenerateTextRequest
 *
 * Request for simple text generation with a single prompt
 */
export const zGenerateTextRequest = z.object({
  prompt: z.string().min(1),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * GenerateObjectRequest
 *
 * Request for structured object generation with a predefined schema type
 */
export const zGenerateObjectRequest = z.object({
  prompt: z.string().min(1),
  schemaType: z.enum(["userProfile", "task", "product", "recipe"]),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * ChatRequest
 *
 * Request for multi-turn AI conversation with message history
 */
export const zChatRequest = z.object({
  messages: z.array(zChatMessageWithSchemaType).min(1),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * StreamTextRequest
 *
 * Request for streaming text generation with a single prompt
 */
export const zStreamTextRequest = z.object({
  prompt: z.string().min(1),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * StreamObjectRequest
 *
 * Request for streaming structured object generation
 */
export const zStreamObjectRequest = z.object({
  prompt: z.string().min(1),
  schemaType: z.enum(["userProfile", "task", "product", "recipe"]),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * StreamChatRequest
 *
 * Request for streaming multi-turn AI conversation
 */
export const zStreamChatRequest = z.object({
  messages: z.array(zChatMessageWithSchemaType).min(1),
  model: z.optional(
    z.enum([
      "OPENAI_GPT_5_NANO",
      "GOOGLE_GEMINI_3_FLASH",
      "CLAUDE_HAIKU_3_5",
      "MISTRAL_SMALL",
    ]),
  ),
  options: z.optional(zAiGenerateOptions),
});

/**
 * PaginationQuerySchema
 *
 * Schema for pagination query
 */
export const zPaginationQuerySchema = z.object({
  offset: z.int().gte(0).lte(9007199254740991).default(0),
  pageSize: z.int().gte(1).lte(100).default(20),
});

/**
 * SortingQueryStringSchema
 *
 * Schema for sorting items
 */
export const zSortingQueryStringSchema = z.string();

/**
 * FilterQueryStringSchema
 *
 * Filtering query string, in the format of "property:rule[:value];property:rule[:value];..."
 * <br> Available rules: eq, neq, gt, gte, lt, lte, like, nlike, in, nin, isnull, isnotnull
 * <br> Available properties: title
 */
export const zFilterQueryStringSchema = z.string();

export const zCommentsControllerPostSlug = z.string();

export const zCommentsControllerGetCommentsFilterItem = z.object({
  property: z.literal("content"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zCommentsControllerGetCommentsFilterArray = z.array(
  zCommentsControllerGetCommentsFilterItem,
);

export const zCommentsControllerGetCommentsSortItem = z.object({
  property: z.union([z.literal("createdAt"), z.literal("authorName")]),
  direction: z.enum(["asc", "desc"]),
});

export const zCommentsControllerGetCommentsSortArray = z.array(
  zCommentsControllerGetCommentsSortItem,
);

export const zCommentsControllerGetCommentRepliesSortItem = z.object({
  property: z.union([z.literal("createdAt"), z.literal("authorName")]),
  direction: z.enum(["asc", "desc"]),
});

export const zCommentsControllerGetCommentRepliesSortArray = z.array(
  zCommentsControllerGetCommentRepliesSortItem,
);

export const zPostControllerGetUserPostsFilterItem = z.object({
  property: z.literal("title"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zPostControllerGetUserPostsFilterArray = z.array(
  zPostControllerGetUserPostsFilterItem,
);

export const zPostControllerGetUserPostsSortItem = z.object({
  property: z.union([z.literal("title"), z.literal("createdAt")]),
  direction: z.enum(["asc", "desc"]),
});

export const zPostControllerGetUserPostsSortArray = z.array(
  zPostControllerGetUserPostsSortItem,
);

export const zPublicPostControllerGetPostsFilterItem = z.object({
  property: z.literal("title"),
  rule: z.enum([
    "eq",
    "neq",
    "gt",
    "gte",
    "lt",
    "lte",
    "like",
    "nlike",
    "in",
    "nin",
    "isnull",
    "isnotnull",
  ]),
  value: z.optional(z.string()),
});

export const zPublicPostControllerGetPostsFilterArray = z.array(
  zPublicPostControllerGetPostsFilterItem,
);

export const zPublicPostControllerGetPostsSortItem = z.object({
  property: z.union([z.literal("title"), z.literal("createdAt")]),
  direction: z.enum(["asc", "desc"]),
});

export const zPublicPostControllerGetPostsSortArray = z.array(
  zPublicPostControllerGetPostsSortItem,
);

export const zAppControllerGetHelloData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zCommentsControllerGetCommentsData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.object({
    filter: z.optional(zCommentsControllerGetCommentsFilterArray),
    sort: z.optional(zCommentsControllerGetCommentsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a paginated list of comments
 */
export const zCommentsControllerGetCommentsResponse = zCommentsSchema;

export const zCommentsControllerCreateCommentData = z.object({
  body: z.object({
    content: z.string().min(1).max(1000),
    parentId: z.optional(
      z
        .uuid()
        .regex(
          /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/,
        ),
    ),
  }),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a comment
 */
export const zCommentsControllerCreateCommentResponse = zCommentSchema;

export const zCommentsControllerGetCommentCountData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zCommentsControllerGetCommentRepliesData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    commentId: z.string(),
    postSlug: z.string(),
  }),
  query: z.object({
    sort: z.optional(zCommentsControllerGetCommentRepliesSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a paginated list of comments
 */
export const zCommentsControllerGetCommentRepliesResponse = zCommentsSchema;

export const zCommentsControllerDeleteCommentData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    commentId: z.string(),
    postSlug: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPostControllerGetUserPostsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    filter: z.optional(zPostControllerGetUserPostsFilterArray),
    sort: z.optional(zPostControllerGetUserPostsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * Schema for a list of user's posts
 */
export const zPostControllerGetUserPostsResponse = zUserPostsSchema;

export const zPostControllerCreatePostData = z.object({
  body: z.object({
    title: z.string().min(1),
    content: z.array(
      z.union([
        z.object({
          type: z.literal("text"),
          data: z.string(),
        }),
        z.object({
          type: z.literal("image"),
          data: z.string(),
        }),
        z.object({
          type: z.literal("video"),
          data: z.string(),
        }),
      ]),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerCreatePostResponse = zUserPostSchema;

export const zPostControllerGetUserPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerGetUserPostResponse = zUserPostSchema;

export const zPostControllerUpdatePostData = z.object({
  body: z.object({
    title: z.optional(z.string().min(1)),
    content: z.optional(
      z.array(
        z.union([
          z.object({
            type: z.literal("text"),
            data: z.string(),
          }),
          z.object({
            type: z.literal("image"),
            data: z.string(),
          }),
          z.object({
            type: z.literal("video"),
            data: z.string(),
          }),
        ]),
      ),
    ),
  }),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * Schema for a user's post
 */
export const zPostControllerUpdatePostResponse = zUserPostSchema;

export const zPostControllerPublishPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPostControllerUnpublishPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    id: z.string(),
  }),
  query: z.optional(z.never()),
});

export const zPublicPostControllerGetRandomPostData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * A public post
 */
export const zPublicPostControllerGetRandomPostResponse = zPublicPostSchema;

export const zPublicPostControllerGetPostData = z.object({
  body: z.optional(z.never()),
  path: z.object({
    slug: z.string(),
  }),
  query: z.optional(z.never()),
});

/**
 * A public post
 */
export const zPublicPostControllerGetPostResponse = zPublicPostSchema;

export const zPublicPostControllerGetPostsData = z.object({
  body: z.optional(z.never()),
  path: z.optional(z.never()),
  query: z.object({
    filter: z.optional(zPublicPostControllerGetPostsFilterArray),
    sort: z.optional(zPublicPostControllerGetPostsSortArray),
    offset: z.int().gte(0).lte(9007199254740991).default(0),
    pageSize: z.int().gte(1).lte(100).default(20),
  }),
});

/**
 * A list of public posts
 */
export const zPublicPostControllerGetPostsResponse = zPublicPostsSchema;

export const zAiExampleControllerGenerateTextData = z.object({
  body: z.object({
    prompt: z.string().min(1),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Response from text generation
 */
export const zAiExampleControllerGenerateTextResponse = zGenerateTextResponse;

export const zAiExampleControllerGenerateObjectData = z.object({
  body: z.object({
    prompt: z.string().min(1),
    schemaType: z.enum(["userProfile", "task", "product", "recipe"]),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Response from structured object generation
 */
export const zAiExampleControllerGenerateObjectResponse =
  zGenerateObjectResponse;

export const zAiExampleControllerChatData = z.object({
  body: z.object({
    messages: z
      .array(
        z.object({
          role: z.enum(["user", "assistant", "system", "tool"]),
          content: z.string(),
          metadata: z.optional(
            z.object({
              isConsideredSystemMessage: z.optional(z.boolean()),
              usage: z.optional(
                z.object({
                  promptTokens: z.number(),
                  completionTokens: z.number(),
                  totalTokens: z.number(),
                }),
              ),
              finishReason: z.optional(z.string()),
              timestamp: z.optional(
                z.iso
                  .datetime()
                  .regex(
                    /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/,
                  ),
              ),
              schemaType: z.optional(
                z.enum(["userProfile", "task", "product", "recipe", "none"]),
              ),
            }),
          ),
        }),
      )
      .min(1),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

/**
 * Response from AI chat conversation
 */
export const zAiExampleControllerChatResponse = zChatResponse;

export const zAiExampleControllerStreamTextData = z.object({
  body: z.object({
    prompt: z.string().min(1),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zAiExampleControllerStreamObjectData = z.object({
  body: z.object({
    prompt: z.string().min(1),
    schemaType: z.enum(["userProfile", "task", "product", "recipe"]),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});

export const zAiExampleControllerStreamChatData = z.object({
  body: z.object({
    messages: z
      .array(
        z.object({
          role: z.enum(["user", "assistant", "system", "tool"]),
          content: z.string(),
          metadata: z.optional(
            z.object({
              isConsideredSystemMessage: z.optional(z.boolean()),
              usage: z.optional(
                z.object({
                  promptTokens: z.number(),
                  completionTokens: z.number(),
                  totalTokens: z.number(),
                }),
              ),
              finishReason: z.optional(z.string()),
              timestamp: z.optional(
                z.iso
                  .datetime()
                  .regex(
                    /^(?:(?:\d\d[2468][048]|\d\d[13579][26]|\d\d0[48]|[02468][048]00|[13579][26]00)-02-29|\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\d|30)|(?:02)-(?:0[1-9]|1\d|2[0-8])))T(?:(?:[01]\d|2[0-3]):[0-5]\d(?::[0-5]\d(?:\.\d+)?)?(?:Z))$/,
                  ),
              ),
              schemaType: z.optional(
                z.enum(["userProfile", "task", "product", "recipe", "none"]),
              ),
            }),
          ),
        }),
      )
      .min(1),
    model: z.optional(
      z.enum([
        "OPENAI_GPT_5_NANO",
        "GOOGLE_GEMINI_3_FLASH",
        "CLAUDE_HAIKU_3_5",
        "MISTRAL_SMALL",
      ]),
    ),
    options: z.optional(
      z.object({
        temperature: z.optional(z.number().gte(0).lte(2)),
        maxTokens: z.optional(z.number().gt(0)),
        topP: z.optional(z.number().gte(0).lte(1)),
        frequencyPenalty: z.optional(z.number().gte(-2).lte(2)),
        presencePenalty: z.optional(z.number().gte(-2).lte(2)),
        maxSteps: z.optional(z.number().gt(0)),
        stopWhen: z.optional(z.number().gt(0)),
        telemetry: z.optional(
          z.object({
            langfuseTraceName: z.string(),
            langfuseOriginalPrompt: z.optional(z.string()),
            functionId: z.optional(z.string()),
          }),
        ),
        metadata: z.optional(z.record(z.string(), z.unknown())),
      }),
    ),
  }),
  path: z.optional(z.never()),
  query: z.optional(z.never()),
});
