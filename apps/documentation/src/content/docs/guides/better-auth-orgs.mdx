---
title: Organizations
description: Guide to integrate the Better Auth Organizations plugin into the project
---

Better Auth, which we already use for authentication in this boilerplate, offers a complete plugin system to extend its features.

The library provides a specific plugin for managing organizations. The [official Better Auth documentation](https://www.better-auth.com/docs/plugins/organization) covers this plugin and all its options in depth.

This guide helps you quickly configure the Organizations plugin in the boilerplate with NestJS and MikroORM.

## File Structure

Since the Organizations plugin is part of Better Auth and works as an integrated system, we will add all organization-related files in the existing `/auth` folder.

Here is the file structure we will modify:

```
apps/api/src/
├── auth/
│   └── auth.entity.ts              (to update)
└── better-auth.config.ts           (to update)
```

### Installation

<br/>

import { Steps } from '@astrojs/starlight/components';

<Steps>

1. ### Add the plugin to Better Auth configuration

   In your Better Auth configuration file `better-auth.config.ts` on the API side, add the `organization` plugin:

   ```typescript
   import { organization } from "better-auth/plugins"

   export const auth = betterAuth({
     // ... your existing config
     plugins: [
       organization() // Minimal configuration
     ]
   })
   ```

   <br/>

2. ### Add organization entities

   The Organizations plugin requires 3 mandatory tables: **Organization**, **Member**, and **Invitation**. There are also optional tables depending on your needs.

   The [official Better Auth schema](https://www.better-auth.com/docs/plugins/organization#schema) details all tables and their fields.

   Add the 3 organization entities to your existing `auth.entity.ts` file:

   ```typescript title="src/auth/auth.entity.ts"
   // ... your existing entities (User, Session, etc.)

   /**
    * Store organization information
    */
   @Entity({ tableName: 'organization' })
   export class Organization {
     @PrimaryKey({ type: 'uuid', defaultRaw: 'gen_random_uuid()' })
     id!: string;

     @Property()
     name!: string;

     @Property({ nullable: true })
     slug?: string;

     @Property({ nullable: true })
     logo?: string;

     @Property({ nullable: true })
     metadata?: string;

     @Property({ fieldName: 'createdAt' })
     createdAt: Date = new Date();

     @OneToMany(() => Member, (member) => member.organization)
     members = new Collection<Member>(this);

     @OneToMany(() => Invitation, (invitation) => invitation.organization)
     invitations = new Collection<Invitation>(this);
   }

   /**
    * Store members of an organization
    */
   @Entity({ tableName: 'member' })
   export class Member {
     @PrimaryKey({ type: 'uuid', defaultRaw: 'gen_random_uuid()' })
     id!: string;

     @ManyToOne(() => User, { fieldName: 'userId', deleteRule: 'cascade' })
     user!: User;

     @ManyToOne(() => Organization, { fieldName: 'organizationId' })
     organization!: Organization;

     @Property({ default: 'member' })
     role = 'member';

     @Property({ fieldName: 'createdAt' })
     createdAt: Date = new Date();
   }

   /**
    * Store invitations to join an organization
    */
   @Entity({ tableName: 'invitation' })
   export class Invitation {
     @PrimaryKey({ type: 'uuid', defaultRaw: 'gen_random_uuid()' })
     id!: string;

     @Property()
     email!: string;

     @ManyToOne(() => User, { fieldName: 'inviterId' })
     inviter!: User;

     @ManyToOne(() => Organization, { fieldName: 'organizationId' })
     organization!: Organization;

     @Property()
     role!: string;

     @Property()
     status!: string;

     @Property({ fieldName: 'expiresAt' })
     expiresAt!: Date;
   }
   ```

   :::tip[Customizing entities]
   You can customize the database table names using the `@Entity({ tableName: '...' })` decorator. For example, you might want to prefix all auth-related tables with `auth_` (like `auth_organization`, `auth_member`, etc.) to keep them organized. You can also add custom fields to your organization entities - see [Extending the schema](#extending-the-schema) below.
   :::

   #### Update the Session entity

   The Better Auth Organizations plugin automatically adds the `activeOrganizationId` field to the session when a user logs in or switches their active organization. You need to add this field to your MikroORM Session entity to match the database schema:

   ```typescript title="src/auth/auth.entity.ts"
   // ... your existing entities
   @Entity(tableName: 'session')
   export class Session {
     // ... your existing properties
     @Property({ fieldName: 'activeOrganizationId', nullable: true })
     activeOrganizationId?: string;
   }
   ```

   :::note[About Active Organization]
   The `activeOrganizationId` field stores which organization the user is currently working in. Users can switch between organizations using `authClient.organization.setActive()`. You can also automatically set the active organization when a session is created using database hooks in `better-auth.config.ts`.

   For detailed information on managing active organizations, see the [Better Auth Active Organization documentation](https://www.better-auth.com/docs/plugins/organization#active-organization).
   :::

   <br/>

3. ### Update the database

   Now that you have added the entities, you need to update your database to create the corresponding tables.

   Depending on your project stage, you can either recreate your database from scratch if you're in development without important data, or use the migration system to preserve existing data.

   :::note[Need help with database updates?]
   For detailed instructions on database migrations and schema updates, check out the [Migrations guide](/guides/migrations) (coming soon).
   :::

   <br/>

4. ### Use the client on the frontend

   Now that everything is configured on the API side, you can use organization-related methods from your frontend client.

   **Usage examples:**

   ```typescript
   // Create an organization
   const { data, error } = await authClient.organization.create({
     name: "My Organization",
     slug: "my-org",
     logo: "https://example.com/logo.png",
   })
   ```

   :::tip
   All available routes and methods are documented in the [official Better Auth - Organizations documentation](https://www.better-auth.com/docs/plugins/organization#create-an-organization).
   :::

    <br/>

</Steps>

The Organizations plugin is now configured and operational. You can create organizations, invite members, and manage roles via the Better Auth client.

## Going further

### Custom business logic

Better Auth provides a complete set of [methods](https://www.better-auth.com/docs/plugins/organization#api-reference) to interact with organization entities (create, update, delete, invite members, etc.).

However, you may need to implement custom business logic specific to your application. In this case, you can create your own methods in `auth.service.ts` to handle organization-related operations that go beyond what Better Auth provides out of the box.

**Example:**

```typescript title="src/auth/auth.service.ts"
//... your existing imports
import { Organization, Member } from './auth.entity'

@Injectable()
export class AuthService {
  constructor(private readonly em: EntityManager) {}
  // ... your existing methods

  async validateOrganizationLimit(userId: string) {
    // Custom business logic: check if user can create more organizations
    // based on their subscription plan
    const memberCount = await this.em.count(Member, { user: userId })

    const userSubscription = await this.getUserSubscription(userId)
    const limit = userSubscription.plan === 'pro' ? 10 : 1

    if (memberCount >= limit) {
      throw new Error(`Organization limit reached for ${userSubscription.plan} plan`)
    }

    return true
  }
}
```

### NestJS Decorators & Guards

The boilerplate already provides authentication decorators and guards. You can extend them to handle organization-specific logic.

**Add organization-related decorators:**

```typescript title="src/auth/auth.decorator.ts"
// ... your existing decorators (@Session, @Public, etc.)

export const RequireOrganization = () => SetMetadata('REQUIRE_ORGANIZATION', true)

export const CurrentOrganization = createParamDecorator(
  (_data: unknown, context: ExecutionContext) => {
    const request = context.switchToHttp().getRequest()
    const session = request.session
    return session?.activeOrganizationId
  },
)
```

**Extend the AuthGuard to check organization permissions:**

```typescript title="src/auth/auth.guard.ts"
// In your existing AuthGuard canActivate method, after session validation:

const requireOrganization = this.reflector.get('REQUIRE_ORGANIZATION', context.getHandler())
if (requireOrganization && !session.activeOrganizationId) {
  throw new UnauthorizedException('Active organization required')
}
```

**Usage in your controllers:**

```typescript
@Controller('projects')
export class ProjectController {
  @Post()
  @RequireOrganization()
  async createProject(
    @CurrentOrganization() orgId: string,
    @Body() dto: CreateProjectDto
  ) {
    // Create project for the active organization
    return this.projectService.create(orgId, dto)
  }
}
```

### Extending the schema

You can add custom fields to the organization entities to match your business needs. Since Better Auth v1.3, custom fields added via `additionalFields` will automatically be available in the API endpoints.

**1. Configure the schema in Better Auth:**

```typescript title="better-auth.config.ts"
export const auth = betterAuth({
  plugins: [
    organization({
      schema: {
        organization: {
          additionalFields: {
            industry: {
              type: "string",
              input: true,
              required: false,
            },
            employeeCount: {
              type: "number",
              input: true,
              required: false,
            }
          }
        }
      }
    })
  ]
})
```

**2. Add the fields to your MikroORM entity:**

```typescript title="src/auth/auth.entity.ts"
@Entity({ tableName: 'organization' })
export class Organization {
  // ... existing fields

  @Property({ nullable: true })
  industry?: string

  @Property({ type: 'int', nullable: true })
  employeeCount?: number
}
```

**3. Configure the client for type inference (optional but recommended):**

```typescript title="auth-client.ts"
import { inferOrgAdditionalFields, organizationClient } from "better-auth/client/plugins"
import type { auth } from "@/auth" // import type only

const client = createAuthClient({
  plugins: [
    organizationClient({
      schema: inferOrgAdditionalFields<typeof auth>(),
    }),
  ],
})
```

:::tip
For complete documentation on customizing organization schemas, roles, permissions, and other advanced features, see the [Better Auth Organizations Schema Customization](https://www.better-auth.com/docs/plugins/organization#customizing-the-schema).
:::
