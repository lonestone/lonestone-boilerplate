---
title: Adding Tracing with Sentry
description: Guide to add Tracing with Sentry to the project
---
import { Steps } from '@astrojs/starlight/components';

You should add Sentry to log traces in your project.

At Lonestone, we use [Sentry](https://sentry.io/) to log traces, but this guide is mostly applicable for alternatives such as [Signoz](https://signoz.io/).

## Tracing Architecture

The boilerplate uses a **unified OpenTelemetry tracing architecture** that integrates both Sentry and Langfuse through a shared TracerProvider. This provides:

- **Distributed Tracing**: Traces are automatically propagated across services
- **Dual Export**: LLM spans go to Langfuse (for prompt management) while all spans go to Sentry (for application monitoring)
- **Automatic Instrumentation**: All application spans (controllers, services, database queries) and AI calls are automatically traced

The shared TracerProvider is configured in `apps/api/src/instrument.ts` and uses:
- **LangfuseSpanProcessor**: Filters and exports only LLM-related spans to Langfuse
- **SentrySpanProcessor**: Receives all spans for Sentry

**Note**: Because of the shared TracerProvider, Langfuse traces will also appear in Sentry, allowing you to see AI calls in the context of full request traces.


<Steps>
1. ### Install and setup the Sentry SDK
   See the [Error Reporting with Sentry](/lonestone-boilerplate/addons/error-reporting-sentry) guide for more details.

2. ### Install the NestJS opentelemetry module and dependencies

    I recommend using the opentelemetry-nestjs package, provided by [Amplication](https://amplication.com), which eases up setting up OTEL in a NestJS project. This package requires the @nestjs/microservices package.

   ```bash
   cd apps/api
   pnpm add @amplication/opentelemetry-nestjs @nestjs/microservices
   ```

   <br/>


3. ### Update the `instrument.ts` file at the root of the API project

   The boilerplate uses a shared TracerProvider architecture that integrates Sentry and Langfuse. The `instrument.ts` file is already configured with this setup.

   **Important**: The boilerplate initializes Sentry with `skipOpenTelemetrySetup: true` to prevent Sentry from claiming the global provider. Instead, a shared TracerProvider is created that includes both Sentry and Langfuse processors.

   ```typescript   title="src/instrument.ts"
        // Sentry is initialized WITHOUT automatic OTEL setup
        Sentry.init({
            // [...] other Sentry config ...

            // Setting this will enable tracing
            // In production with high traffic, you should set this to a lower value.
            tracesSampleRate: 1.0,

            // Setting this option to true will send default PII data to Sentry.
            // For example, automatic IP address collection on events
            sendDefaultPii: true,

            // Critical: prevents Sentry from claiming global provider
            skipOpenTelemetrySetup: true,
        })

        // Shared TracerProvider is created with both Sentry and Langfuse processors
        async function initSharedTracerProvider() {
            // Creates shared provider with both processors
            // See apps/api/src/instrument.ts for full implementation
        }
   ```

   The `initSharedTracerProvider()` function is automatically called in `main.ts` before the NestJS app is created.

   <br/>

4. ### Setup NestJS opentelemetry
    The Amplication package provides good defaults to log traces to Sentry, and is quite easy to setup.

    ```typescript   title="src/app.module.ts"
        // [...] other imports //
        import { NestjsOpenTelemetryModule } from '@amplication/opentelemetry-nestjs'

        @Module({
        imports: [
            NestjsOpenTelemetryModule.forRoot(),
        ],
    })
    export class AppModule {}
    ```

   <br/>

5. ### Test your setup
    Open Yaak or Postman and make a request to the API. You should see traces in Sentry.

    ![Sentry traces](../../../assets/sentry_traces.png)
   
     <br/>

6. ### Add tracing to your code
    By default, OTEL does not capture all your method calls (only guards, controllers, db queries, etc.). 
    
    To get more granular details, you can add tracing to your code by using the `@Traceable()` decorator at the class level. This is highly recommended.
    ```typescript
    @Traceable()
    @Injectable()
    export class UserService {
        constructor(private readonly userRepository: UserRepository) {}
    }
    ```
    ![Sentry traces](../../../assets/sentry_traces_traceable.png)
    
    On the left, the added granularity is visible (we can see the service). With more method calls, this can allow for easier performance analysis.

</Steps>
