---
title: Design Philosophy
description: Why we chose some tools, why we chose the "removal" path, etc.
---

The goal of this project is to provide a ready-to-use boilerplate that is both robust, flexible enough to accomodate the diverse projects Lonestone is working on, and easy to use and maintain.

## üîç Overview
This project uses a "monorepo" architecture. The advantages are numerous, but primarily:

- Ability to develop full-stack features without context switching, making a single PR for a complete feature
- Easier deployment: no need to synchronize multiple separate deployments
- Strong end-to-end typing, easier refactoring
- Simplified and unified tooling (linter, build, etc.)

:::note 
While this approach could cause problems on really large codebase, with a lot of developers making changes at the same time, it's a good fit for small to medium-sized projects like we handle at Lonestone.
:::

## Finding balance between features

As the boilerplate is meant to be a starting point for new projects, we need to find a balance between features that are useful for most projects, and features that are only useful for specific projects.

In a perfect world, we would have a CLI tool allowing the user to create a project with a specific set of features. Sadly, the devil is in the details: a lot of features are tighly coupled, or modify the same files, making it hard to combine them in a CLI.

We choose to propose a all-in-one, ready-to-use solution. The promise is that you can clone the repo and start coding right away.

For this strategy to pay off, we need to **keep the boilerplate as simple as possible.**

Hence why adding a new feature to the boilerplate codebase must be done with care. A simple rule of thumb is to check if the feature is used in 80% of Lonestone's projects. If not, it's probably not worth adding it to the boilerplate.

## Why we chose the "removal" path
In addition to the balance between features, we needed to find a balance between keeping the boilerplate codebase clean, and making it easy to update the codebase.

As previously stated, CLI tools are hard to set-up and maintain. We will provide simple instructions on how to remove features from the boilerplate.

- Removing elements from the repo is easier (for now) that creating a whole bunch of modular packages to combine
- Upgradability is not a priority for us. Once a project is launched, we will not upgrade the dependencies that much (doing it manually is OK)
- We don't have the staff to maintain a lot of packages, sync their versions, etc.
